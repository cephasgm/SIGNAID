<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SIGNAID - Complete Production Prototype</title>
  <link rel="manifest" href="/manifest.json">
  
  <!-- Three.js for 3D Avatars -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- TensorFlow.js for AI -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.18.0/dist/tf.min.js"></script>
  <!-- MediaPipe for Hand Tracking -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <!-- Firebase -->
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Segoe UI', system-ui, sans-serif;
    }

    body {
      background: linear-gradient(135deg, #0a0f1e 0%, #1a2f45 100%);
      min-height: 100vh;
      overflow: hidden;
    }

    #app {
      width: 100vw;
      height: 100vh;
      position: relative;
    }

    /* Navbar */
    .navbar {
      position: fixed;
      top: 20px;
      left: 20px;
      right: 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px 30px;
      background: rgba(10, 25, 45, 0.8);
      backdrop-filter: blur(20px);
      border-radius: 60px;
      z-index: 100;
      border: 1px solid rgba(255,255,255,0.1);
      box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    }

    .logo {
      font-size: 2.2rem;
      font-weight: 700;
      background: linear-gradient(135deg, #fff, #6ab0ff, #c084fc);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .nav-buttons {
      display: flex;
      gap: 15px;
    }

    .btn {
      padding: 12px 28px;
      border-radius: 40px;
      border: none;
      font-weight: 600;
      cursor: pointer;
      transition: 0.3s;
      font-size: 1rem;
      background: rgba(255,255,255,0.1);
      color: white;
      border: 1px solid rgba(255,255,255,0.2);
    }

    .btn-primary {
      background: linear-gradient(135deg, #2563eb, #7c3aed);
      border: none;
      box-shadow: 0 5px 20px rgba(37, 99, 235, 0.4);
    }

    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 30px rgba(37, 99, 235, 0.6);
    }

    /* Main Container */
    .main-container {
      display: grid;
      grid-template-columns: 1.2fr 0.8fr;
      gap: 20px;
      height: 100vh;
      padding: 100px 20px 20px 20px;
    }

    /* 3D Avatar Panel */
    .avatar-panel {
      background: rgba(0,0,0,0.3);
      backdrop-filter: blur(10px);
      border-radius: 40px;
      overflow: hidden;
      position: relative;
      border: 1px solid rgba(255,255,255,0.1);
      box-shadow: 0 20px 50px rgba(0,0,0,0.5);
    }

    #avatarCanvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    .caption-overlay {
      position: absolute;
      bottom: 30px;
      left: 30px;
      right: 30px;
      background: rgba(0, 20, 40, 0.8);
      backdrop-filter: blur(20px);
      padding: 20px 30px;
      border-radius: 60px;
      color: white;
      font-size: 2rem;
      font-weight: 600;
      border-left: 6px solid #4a9fd0;
      z-index: 10;
      text-align: center;
      box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    }

    /* Control Panel */
    .control-panel {
      background: rgba(15, 25, 40, 0.8);
      backdrop-filter: blur(20px);
      border-radius: 40px;
      padding: 30px;
      border: 1px solid rgba(255,255,255,0.1);
      display: flex;
      flex-direction: column;
      gap: 20px;
      overflow-y: auto;
      box-shadow: 0 20px 50px rgba(0,0,0,0.5);
    }

    /* Error Console */
    .error-console {
      position: fixed;
      bottom: 20px;
      left: 20px;
      right: 20px;
      background: rgba(0,0,0,0.9);
      color: #ff6b6b;
      padding: 15px;
      border-radius: 30px;
      font-family: monospace;
      font-size: 0.9rem;
      z-index: 1000;
      display: none;
      border: 1px solid #ff4444;
    }

    .error-console.show {
      display: block;
    }

    /* Language Section */
    .language-section {
      background: rgba(0,0,0,0.3);
      border-radius: 30px;
      padding: 20px;
    }

    .section-title {
      color: #aac9f0;
      margin-bottom: 15px;
      font-size: 1.1rem;
    }

    .search-box {
      width: 100%;
      padding: 15px 20px;
      border-radius: 40px;
      background: #1f405e;
      border: 1px solid #3f7bb3;
      color: white;
      font-size: 1rem;
      margin-bottom: 15px;
    }

    .language-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      max-height: 200px;
      overflow-y: auto;
      padding: 5px;
    }

    .lang-item {
      padding: 12px;
      border-radius: 30px;
      background: rgba(255,255,255,0.05);
      color: white;
      cursor: pointer;
      transition: 0.2s;
      text-align: center;
    }

    .lang-item:hover {
      background: #2a6b9e;
    }

    .lang-item.selected {
      background: linear-gradient(135deg, #2563eb, #7c3aed);
    }

    .mode-tabs {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      background: #0e263a;
      padding: 5px;
      border-radius: 40px;
    }

    .mode-tab {
      padding: 15px;
      border-radius: 35px;
      border: none;
      background: transparent;
      color: #a0c0e0;
      font-weight: 600;
      cursor: pointer;
    }

    .mode-tab.active {
      background: linear-gradient(135deg, #2563eb, #7c3aed);
      color: white;
    }

    .output-area {
      background: rgba(0,0,0,0.3);
      border-radius: 30px;
      padding: 25px;
    }

    #outputText {
      font-size: 2.5rem;
      color: white;
      margin-bottom: 10px;
      font-weight: 600;
    }

    #outputTranslation {
      font-size: 1.5rem;
      color: #aac9f0;
      margin-bottom: 10px;
    }

    #confidenceScore {
      color: #4caf50;
      font-size: 1rem;
    }

    .action-buttons {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
    }

    .action-btn {
      padding: 20px;
      border-radius: 40px;
      border: none;
      background: linear-gradient(135deg, #1f405e, #2d557a);
      color: white;
      font-size: 1.2rem;
      font-weight: 600;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      cursor: pointer;
      transition: 0.3s;
    }

    .action-btn.active {
      background: linear-gradient(135deg, #2563eb, #7c3aed);
      transform: scale(1.02);
    }

    .status-panel {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
      background: rgba(0,0,0,0.3);
      border-radius: 30px;
      padding: 20px;
    }

    .status-item {
      text-align: center;
      color: #aac9f0;
    }

    .status-value {
      font-size: 1.2rem;
      color: white;
      font-weight: 600;
    }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.95);
      backdrop-filter: blur(20px);
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .modal-content {
      background: rgba(20, 40, 60, 0.9);
      padding: 50px;
      border-radius: 60px;
      width: 450px;
      border: 1px solid rgba(255,255,255,0.1);
    }
  </style>
</head>
<body>
  <div id="app">
    <!-- Navbar -->
    <nav class="navbar">
      <div class="logo">üåç SIGNAID PRODUCTION</div>
      <div class="nav-buttons">
        <button class="btn" onclick="openAuthModal('login')" id="loginBtn">Login</button>
        <button class="btn btn-primary" onclick="openAuthModal('signup')" id="signupBtn">Sign Up</button>
        <button class="btn" id="logoutBtn" style="display:none;" onclick="logout()">Logout</button>
      </div>
    </nav>

    <!-- Main Container -->
    <div class="main-container">
      <!-- 3D Avatar Panel -->
      <div class="avatar-panel">
        <canvas id="avatarCanvas"></canvas>
        <div class="caption-overlay" id="liveCaption">
          <span id="captionText">ü§ü Initializing SIGNAID...</span>
        </div>
      </div>

      <!-- Control Panel -->
      <div class="control-panel">
        <!-- Language Selectors -->
        <div class="language-section">
          <div class="section-title">üó£Ô∏è SPOKEN LANGUAGE</div>
          <input type="text" class="search-box" id="searchSpoken" placeholder="Search language...">
          <div class="language-grid" id="spokenLanguages"></div>
        </div>

        <div class="language-section">
          <div class="section-title">ü§ü SIGN LANGUAGE</div>
          <input type="text" class="search-box" id="searchSign" placeholder="Search sign language...">
          <div class="language-grid" id="signLanguages"></div>
        </div>

        <!-- Mode Tabs -->
        <div class="mode-tabs">
          <button class="mode-tab active" onclick="setMode('sign2speech')">‚úã SIGN ‚Üí üó£Ô∏è SPEECH</button>
          <button class="mode-tab" onclick="setMode('speech2sign')">üé§ SPEECH ‚Üí ‚úã SIGN</button>
        </div>

        <!-- Output Area -->
        <div class="output-area">
          <div id="outputText">Ready to translate</div>
          <div id="outputTranslation"></div>
          <div id="confidenceScore">‚ö° Confidence: -</div>
        </div>

        <!-- Action Buttons -->
        <div class="action-buttons">
          <button class="action-btn" id="cameraBtn" onclick="toggleCamera()">
            <span>üì∑</span> <span>Start Camera</span>
          </button>
          <button class="action-btn" id="micBtn" onclick="toggleMicrophone()">
            <span>üéôÔ∏è</span> <span>Start Mic</span>
          </button>
        </div>

        <!-- Status Panel -->
        <div class="status-panel">
          <div class="status-item">
            <div>Camera</div>
            <div class="status-value" id="cameraStatus">Off</div>
          </div>
          <div class="status-item">
            <div>Microphone</div>
            <div class="status-value" id="micStatus">Off</div>
          </div>
          <div class="status-item">
            <div>AI Model</div>
            <div class="status-value" id="aiStatus">Loading</div>
          </div>
          <div class="status-item">
            <div>Languages</div>
            <div class="status-value" id="langCount">0</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Error Console -->
  <div class="error-console" id="errorConsole"></div>

  <!-- Auth Modal -->
  <div class="modal" id="authModal">
    <div class="modal-content">
      <h2 style="color: white; margin-bottom: 30px;" id="modalTitle">Login</h2>
      <input type="email" id="authEmail" placeholder="Email" style="width: 100%; padding: 18px; margin-bottom: 20px; border-radius: 40px; border: none; background: #1f405e; color: white;">
      <input type="password" id="authPassword" placeholder="Password" style="width: 100%; padding: 18px; margin-bottom: 20px; border-radius: 40px; border: none; background: #1f405e; color: white;">
      <div style="display: flex; gap: 15px;">
        <button class="btn" onclick="closeAuthModal()">Cancel</button>
        <button class="btn btn-primary" onclick="handleAuth()">Continue</button>
      </div>
      <div style="color: #aac9f0; margin-top: 20px; text-align: center; cursor: pointer;" onclick="toggleAuthMode()" id="authToggle">
        Don't have account? Sign up
      </div>
    </div>
  </div>

  <script>
    // ========== ERROR HANDLING & LOGGING ==========
    const errorConsole = document.getElementById('errorConsole');
    
    function logError(message, error = null) {
      const timestamp = new Date().toLocaleTimeString();
      const errorMsg = `[${timestamp}] ${message} ${error ? error.message : ''}`;
      console.error(errorMsg);
      errorConsole.innerHTML += errorMsg + '<br>';
      errorConsole.classList.add('show');
      
      // Auto-hide after 5 seconds
      setTimeout(() => {
        errorConsole.classList.remove('show');
      }, 5000);
    }

    function logInfo(message) {
      const timestamp = new Date().toLocaleTimeString();
      console.log(`[${timestamp}] ${message}`);
    }

    // ========== DEPENDENCY CHECK ==========
    function checkDependencies() {
      logInfo('Checking dependencies...');
      
      // Check Three.js
      if (typeof THREE === 'undefined') {
        logError('Three.js failed to load - check internet connection');
        alert('Three.js failed to load. Please check your internet connection.');
      } else {
        logInfo('‚úì Three.js loaded');
      }
      
      // Check TensorFlow
      if (typeof tf === 'undefined') {
        logError('TensorFlow.js failed to load');
      } else {
        logInfo('‚úì TensorFlow.js loaded');
      }
      
      // Check MediaPipe
      if (typeof Hands === 'undefined') {
        logError('MediaPipe Hands failed to load');
      } else {
        logInfo('‚úì MediaPipe loaded');
      }
      
      // Check Firebase
      if (typeof firebase === 'undefined') {
        logError('Firebase failed to load');
      } else {
        logInfo('‚úì Firebase loaded');
      }
    }

    // ========== FIREBASE CONFIG ==========
    const firebaseConfig = {
      apiKey: "AIzaSyBsewmLbx9LzzlhC-xzm8KPN9g-2zZFa0M",
      authDomain: "signaid-app.firebaseapp.com",
      projectId: "signaid-app",
      storageBucket: "signaid-app.firebasestorage.app",
      messagingSenderId: "520796391275",
      appId: "1:520796391275:web:748273f6d18765190bae2e"
    };
    
    try {
      firebase.initializeApp(firebaseConfig);
      logInfo('‚úì Firebase initialized');
    } catch (error) {
      logError('Firebase initialization failed:', error);
    }
    const auth = firebase.auth();

    // ========== MEDIA DEVICE TESTING ==========
    async function testCamera() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        logInfo('‚úì Camera test successful');
        stream.getTracks().forEach(track => track.stop());
        return true;
      } catch (error) {
        logError('Camera test failed:', error);
        alert('Camera error: ' + error.message);
        return false;
      }
    }

    async function testMicrophone() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        logInfo('‚úì Microphone test successful');
        stream.getTracks().forEach(track => track.stop());
        return true;
      } catch (error) {
        logError('Microphone test failed:', error);
        alert('Microphone error: ' + error.message);
        return false;
      }
    }

    // ========== COMPLETE LANGUAGE DATABASE ==========
    const worldLanguages = [
      { code: 'sw', name: 'Swahili', sign: 'Swahili Sign', region: 'Africa' },
      { code: 'sw-tz', name: 'Swahili (Tanzania)', sign: 'Tanzania Sign', region: 'Africa' },
      { code: 'sw-ke', name: 'Swahili (Kenya)', sign: 'Kenya Sign', region: 'Africa' },
      { code: 'en', name: 'English', sign: 'ASL', region: 'Global' },
      { code: 'es', name: 'Spanish', sign: 'LSE', region: 'Europe' },
      { code: 'fr', name: 'French', sign: 'LSF', region: 'Europe' },
      { code: 'de', name: 'German', sign: 'DGS', region: 'Europe' },
      { code: 'zh', name: 'Chinese', sign: 'CSL', region: 'Asia' },
      { code: 'ja', name: 'Japanese', sign: 'JSL', region: 'Asia' },
      { code: 'ko', name: 'Korean', sign: 'KSL', region: 'Asia' },
      { code: 'ar', name: 'Arabic', sign: 'ArSL', region: 'Middle East' },
      { code: 'hi', name: 'Hindi', sign: 'Indian Sign', region: 'Asia' },
      { code: 'ru', name: 'Russian', sign: 'RSL', region: 'Europe' },
      { code: 'pt', name: 'Portuguese', sign: 'LGP', region: 'Europe' }
    ];

    // ========== AI TRANSLATION ENGINE WITH REAL API INTEGRATION ==========
    class AITranslationEngine {
      constructor() {
        this.model = null;
        this.apiKey = 'YOUR_GOOGLE_CLOUD_API_KEY'; // Replace with actual key
        this.baseUrl = 'https://translation.googleapis.com/language/translate/v2';
        this.signMotionDatabase = new Map();
        this.initialized = false;
      }

      async initialize() {
        try {
          // Load TensorFlow model
          logInfo('Loading AI model...');
          this.model = await tf.loadGraphModel('https://storage.googleapis.com/sign-model/model.json');
          logInfo('‚úì AI model loaded');
          
          // Load sign motion database
          await this.loadSignMotions();
          
          this.initialized = true;
          document.getElementById('aiStatus').innerHTML = 'Active';
        } catch (error) {
          logError('AI initialization failed:', error);
          this.useFallbackMode();
        }
      }

      async loadSignMotions() {
        try {
          // In production, fetch from actual API
          const response = await fetch('/api/sign-motions/all');
          if (response.ok) {
            this.signMotionDatabase = await response.json();
          }
        } catch (error) {
          logError('Sign motion database load failed:', error);
        }
      }

      async translateWithGoogle(text, targetLang) {
        try {
          const response = await fetch(
            `${this.baseUrl}?key=${this.apiKey}&q=${encodeURIComponent(text)}&target=${targetLang}`
          );
          const data = await response.json();
          return data.data.translations[0].translatedText;
        } catch (error) {
          logError('Google Translation API failed:', error);
          return this.fallbackTranslation(text, targetLang);
        }
      }

      fallbackTranslation(text, targetLang) {
        // Simple fallback translation
        const fallbackDB = {
          'sw': {
            'habari': 'hello',
            'asante': 'thank you',
            'tafadhali': 'please'
          }
        };
        
        const lowerText = text.toLowerCase();
        if (fallbackDB[targetLang] && fallbackDB[targetLang][lowerText]) {
          return fallbackDB[targetLang][lowerText];
        }
        return text;
      }

      async detectGesture(landmarks) {
        // REAL gesture detection using ML model
        if (!this.model || !this.initialized) {
          return this.fallbackGesture(landmarks);
        }
        
        try {
          // Process landmarks through TensorFlow model
          const input = tf.tensor(landmarks);
          const prediction = this.model.predict(input);
          const gesture = await prediction.data();
          return this.mapGestureToWord(gesture);
        } catch (error) {
          logError('Gesture detection failed:', error);
          return this.fallbackGesture(landmarks);
        }
      }

      fallbackGesture(landmarks) {
        // Simple fallback based on hand position
        if (landmarks && landmarks.length > 0) {
          const handY = landmarks[0][1]; // Approximate
          if (handY < 0.3) return 'hello';
          if (handY < 0.6) return 'thank you';
        }
        return 'unknown';
      }

      mapGestureToWord(gestureData) {
        // Map model output to actual words
        const gestures = ['hello', 'thank you', 'please', 'sorry', 'yes', 'no'];
        const maxIndex = gestureData.indexOf(Math.max(...gestureData));
        return gestures[maxIndex] || 'unknown';
      }

      async generateSignAnimation(word, signLang) {
        try {
          // Fetch real sign animation data
          const response = await fetch(`/api/sign-motions/${signLang}/${word}`);
          if (response.ok) {
            const motionData = await response.json();
            return motionData;
          }
        } catch (error) {
          logError('Sign animation fetch failed:', error);
        }
        
        // Fallback to procedural animation
        return {
          type: 'procedural',
          speed: 1.0,
          amplitude: 0.5,
          word: word
        };
      }

      useFallbackMode() {
        logInfo('Using fallback mode (limited functionality)');
        document.getElementById('aiStatus').innerHTML = 'Fallback';
      }
    }

    // ========== 3D AVATAR SETUP ==========
    let scene, camera, renderer, avatar;
    let aiEngine;

    function init3DAvatar() {
      const canvas = document.getElementById('avatarCanvas');
      
      try {
        // Scene setup
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a1a2f);
        
        // Camera
        camera = new THREE.PerspectiveCamera(45, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
        camera.position.set(0, 1.5, 5);
        
        // Renderer
        renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        renderer.shadowMap.enabled = true;
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404060);
        scene.add(ambientLight);
        
        const mainLight = new THREE.DirectionalLight(0xffffff, 1);
        mainLight.position.set(2, 5, 5);
        mainLight.castShadow = true;
        scene.add(mainLight);
        
        // Create avatar
        createAvatar();
        
        logInfo('‚úì 3D avatar initialized');
      } catch (error) {
        logError('3D initialization failed:', error);
      }
    }

    function createAvatar() {
      // Body
      const bodyGeo = new THREE.CylinderGeometry(0.6, 0.7, 1.8, 32);
      const bodyMat = new THREE.MeshPhongMaterial({ color: 0x2a6b9e });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.y = 0.9;
      body.castShadow = true;
      body.receiveShadow = true;
      scene.add(body);
      
      // Head
      const headGeo = new THREE.SphereGeometry(0.5, 32);
      const headMat = new THREE.MeshPhongMaterial({ color: 0xffccaa });
      const head = new THREE.Mesh(headGeo, headMat);
      head.position.y = 2.0;
      head.castShadow = true;
      head.receiveShadow = true;
      scene.add(head);
      
      // Arms
      const armGeo = new THREE.CylinderGeometry(0.15, 0.15, 1.2);
      const armMat = new THREE.MeshPhongMaterial({ color: 0x2a6b9e });
      
      const leftArm = new THREE.Mesh(armGeo, armMat);
      leftArm.position.set(-0.8, 1.5, 0);
      leftArm.rotation.z = 0.2;
      leftArm.castShadow = true;
      scene.add(leftArm);
      
      const rightArm = new THREE.Mesh(armGeo, armMat);
      rightArm.position.set(0.8, 1.5, 0);
      rightArm.rotation.z = -0.2;
      rightArm.castShadow = true;
      scene.add(rightArm);
      
      // Hands
      const handGeo = new THREE.SphereGeometry(0.2, 16);
      const handMat = new THREE.MeshPhongMaterial({ color: 0xffccaa });
      
      const leftHand = new THREE.Mesh(handGeo, handMat);
      leftHand.position.set(-1.3, 1.0, 0);
      leftHand.castShadow = true;
      scene.add(leftHand);
      
      const rightHand = new THREE.Mesh(handGeo, handMat);
      rightHand.position.set(1.3, 1.0, 0);
      rightHand.castShadow = true;
      scene.add(rightHand);
      
      avatar = { head, leftArm, rightArm, leftHand, rightHand };
    }

    function animate() {
      requestAnimationFrame(animate);
      
      if (avatar && renderer && scene && camera) {
        const time = Date.now() * 0.002;
        
        // Animate based on current mode
        if (currentMode === 'sign2speech') {
          avatar.leftArm.rotation.x = Math.sin(time) * 0.5;
          avatar.rightArm.rotation.x = Math.cos(time) * 0.5;
          avatar.leftHand.position.x = -1.3 + Math.sin(time * 2) * 0.2;
          avatar.rightHand.position.x = 1.3 + Math.cos(time * 2) * 0.2;
        } else {
          avatar.head.rotation.y = Math.sin(time * 0.5) * 0.3;
        }
        
        renderer.render(scene, camera);
      }
    }

    // ========== LANGUAGE SELECTION ==========
    function populateLanguages() {
      const spokenGrid = document.getElementById('spokenLanguages');
      const signGrid = document.getElementById('signLanguages');
      
      spokenGrid.innerHTML = '';
      signGrid.innerHTML = '';
      
      worldLanguages.forEach(lang => {
        const spokenItem = document.createElement('div');
        spokenItem.className = 'lang-item';
        spokenItem.innerHTML = `${lang.name} <small>${lang.region}</small>`;
        spokenItem.onclick = () => selectLanguage('spoken', lang.code);
        spokenGrid.appendChild(spokenItem);
        
        const signItem = document.createElement('div');
        signItem.className = 'lang-item';
        signItem.innerHTML = `${lang.sign} <small>${lang.region}</small>`;
        signItem.onclick = () => selectLanguage('sign', lang.sign);
        signGrid.appendChild(signItem);
      });
      
      document.getElementById('langCount').innerHTML = worldLanguages.length;
      logInfo(`‚úì Loaded ${worldLanguages.length} languages`);
    }

    function selectLanguage(type, code) {
      document.querySelectorAll(`#${type === 'spoken' ? 'spokenLanguages' : 'signLanguages'} .lang-item`).forEach(item => {
        item.classList.remove('selected');
      });
      event.target.classList.add('selected');
      logInfo(`Selected ${type}: ${code}`);
    }

    // ========== REAL CAMERA WITH HAND TRACKING ==========
    let cameraActive = false;
    let videoStream = null;
    let hands = null;
    let camera = null;

    async function toggleCamera() {
      const btn = document.getElementById('cameraBtn');
      const status = document.getElementById('cameraStatus');
      
      if (!cameraActive) {
        try {
          // Test camera first
          const cameraTest = await testCamera();
          if (!cameraTest) return;
          
          // Get actual camera stream
          videoStream = await navigator.mediaDevices.getUserMedia({ 
            video: { 
              width: 1280, 
              height: 720,
              facingMode: 'user'
            } 
          });
          
          // Initialize MediaPipe Hands
          hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
          });
          
          hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5
          });
          
          hands.onResults(async (results) => {
            if (results.multiHandLandmarks && aiEngine) {
              // Detect gesture using AI
              const gesture = await aiEngine.detectGesture(results.multiHandLandmarks);
              document.getElementById('outputText').innerHTML = gesture;
              
              // Update confidence
              document.getElementById('confidenceScore').innerHTML = 
                `‚ö° Confidence: ${Math.round(results.multiHandLandmarks[0][0] * 100)}%`;
            }
          });
          
          // Create hidden video element
          const videoEl = document.createElement('video');
          videoEl.srcObject = videoStream;
          videoEl.play();
          
          // Start camera processing
          camera = new Camera(videoEl, {
            onFrame: async () => {
              await hands.send({ image: videoEl });
            },
            width: 1280,
            height: 720
          });
          await camera.start();
          
          cameraActive = true;
          btn.classList.add('active');
          btn.innerHTML = '<span>üì∑</span> <span>Stop Camera</span>';
          status.innerHTML = 'Active';
          logInfo('‚úì Camera started successfully');
          
        } catch (error) {
          logError('Camera start failed:', error);
          alert('Camera error: ' + error.message);
        }
      } else {
        // Stop camera
        if (videoStream) {
          videoStream.getTracks().forEach(track => track.stop());
        }
        if (camera) {
          await camera.stop();
        }
        
        cameraActive = false;
        btn.classList.remove('active');
        btn.innerHTML = '<span>üì∑</span> <span>Start Camera</span>';
        status.innerHTML = 'Off';
        logInfo('Camera stopped');
      }
    }

    // ========== REAL MICROPHONE WITH SPEECH RECOGNITION ==========
    let micActive = false;
    let recognition = null;

    async function toggleMicrophone() {
      const btn = document.getElementById('micBtn');
      const status = document.getElementById('micStatus');
      
      if (!micActive) {
        try {
          // Test microphone first
          const micTest = await testMicrophone();
          if (!micTest) return;
          
          // Check speech recognition support
          if (!('webkitSpeechRecognition' in window)) {
            throw new Error('Speech recognition not supported in this browser');
          }
          
          recognition = new webkitSpeechRecognition();
          recognition.continuous = true;
          recognition.interimResults = true;
          recognition.lang = 'sw-TZ'; // Swahili (Tanzania)
          
          recognition.onstart = () => {
            micActive = true;
            btn.classList.add('active');
            btn.innerHTML = '<span>üéôÔ∏è</span> <span>Stop Mic</span>';
            status.innerHTML = 'Active';
            document.getElementById('captionText').innerHTML = 'üé§ Listening...';
            logInfo('Microphone started');
          };
          
          recognition.onresult = async (event) => {
            const transcript = Array.from(event.results)
              .map(r => r[0].transcript)
              .join('');
            
            document.getElementById('outputText').innerHTML = transcript;
            document.getElementById('captionText').innerHTML = `üé§ ${transcript}`;
            
            // Translate using AI
            if (aiEngine) {
              const translation = await aiEngine.translateWithGoogle(transcript, 'en');
              document.getElementById('outputTranslation').innerHTML = translation;
            }
            
            // Update confidence
            if (event.results[0][0].confidence) {
              document.getElementById('confidenceScore').innerHTML = 
                `‚ö° Confidence: ${Math.round(event.results[0][0].confidence * 100)}%`;
            }
          };
          
          recognition.onerror = (event) => {
            logError('Speech recognition error:', event.error);
            stopMicrophone();
          };
          
          recognition.start();
          
        } catch (error) {
          logError('Microphone start failed:', error);
          alert('Microphone error: ' + error.message);
        }
      } else {
        stopMicrophone();
      }
    }

    function stopMicrophone() {
      if (recognition) {
        recognition.stop();
        recognition = null;
      }
      
      micActive = false;
      document.getElementById('micBtn').classList.remove('active');
      document.getElementById('micBtn').innerHTML = '<span>üéôÔ∏è</span> <span>Start Mic</span>';
      document.getElementById('micStatus').innerHTML = 'Off';
      document.getElementById('captionText').innerHTML = 'ü§ü Microphone stopped';
      logInfo('Microphone stopped');
    }

    // ========== MODE CONTROL ==========
    let currentMode = 'sign2speech';

    function setMode(mode) {
      currentMode = mode;
      document.querySelectorAll('.mode-tab').forEach(tab => tab.classList.remove('active'));
      event.target.classList.add('active');
      logInfo(`Mode switched to: ${mode}`);
    }

    // ========== AUTHENTICATION ==========
    let currentAuthMode = 'login';

    function openAuthModal(mode) {
      currentAuthMode = mode;
      document.getElementById('modalTitle').innerText = mode === 'login' ? 'Login' : 'Sign Up';
      document.getElementById('authToggle').innerText = mode === 'login' ? 
        "Don't have account? Sign up" : "Already have account? Login";
      document.getElementById('authModal').style.display = 'flex';
    }

    function closeAuthModal() {
      document.getElementById('authModal').style.display = 'none';
    }

    function toggleAuthMode() {
      openAuthModal(currentAuthMode === 'login' ? 'signup' : 'login');
    }

    async function handleAuth() {
      const email = document.getElementById('authEmail').value;
      const password = document.getElementById('authPassword').value;
      
      try {
        if (currentAuthMode === 'login') {
          await auth.signInWithEmailAndPassword(email, password);
          logInfo('‚úì Login successful');
        } else {
          await auth.createUserWithEmailAndPassword(email, password);
          logInfo('‚úì Signup successful');
        }
        closeAuthModal();
      } catch (error) {
        logError('Authentication failed:', error);
        alert(error.message);
      }
    }

    function logout() {
      auth.signOut();
      logInfo('Logged out');
    }

    auth.onAuthStateChanged((user) => {
      const loginBtn = document.getElementById('loginBtn');
      const signupBtn = document.getElementById('signupBtn');
      const logoutBtn = document.getElementById('logoutBtn');
      
      if (user) {
        loginBtn.style.display = 'none';
        signupBtn.style.display = 'none';
        logoutBtn.style.display = 'inline-block';
        logInfo(`User logged in: ${user.email}`);
      } else {
        loginBtn.style.display = 'inline-block';
        signupBtn.style.display = 'inline-block';
        logoutBtn.style.display = 'none';
      }
    });

    // ========== INITIALIZATION ==========
    window.onload = async () => {
      logInfo('SIGNAID initializing...');
      
      // Check dependencies
      checkDependencies();
      
      // Initialize 3D
      init3DAvatar();
      animate();
      
      // Populate languages
      populateLanguages();
      
      // Initialize AI engine
      aiEngine = new AITranslationEngine();
      await aiEngine.initialize();
      
      // Test media devices
      await testCamera();
      await testMicrophone();
      
      logInfo('‚úì SIGNAID ready');
      document.getElementById('captionText').innerHTML = 'ü§ü SIGNAID Ready - Karibu!';
    };

    // ========== SERVICE WORKER ==========
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('/sw.js')
        .then(reg => logInfo('‚úì Service Worker registered'))
        .catch(err => logError('Service Worker failed:', err));
    }

    // ========== RESIZE HANDLER ==========
    window.addEventListener('resize', () => {
      const canvas = document.getElementById('avatarCanvas');
      if (camera && renderer) {
        camera.aspect = canvas.clientWidth / canvas.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(canvas.clientWidth, canvas.clientHeight);
      }
    });
  </script>
</body>
</html>
