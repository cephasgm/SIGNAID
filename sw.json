// SIGNAID Service Worker v2.1.0
// Production-ready with advanced caching strategies

const CACHE_NAME = 'signaid-v2';
const OFFLINE_URL = '/offline.html';
const API_CACHE_NAME = 'signaid-api-v1';
const MEDIA_CACHE_NAME = 'signaid-media-v1';

// Static assets to cache on install
const STATIC_ASSETS = [
  '/',
  '/index.html',
  '/offline.html',
  '/manifest.json',
  '/icons/icon-72x72.png',
  '/icons/icon-96x96.png',
  '/icons/icon-128x128.png',
  '/icons/icon-144x144.png',
  '/icons/icon-152x152.png',
  '/icons/icon-192x192.png',
  '/icons/icon-384x384.png',
  '/icons/icon-512x512.png',
  '/icons/maskable-icon-192x192.png',
  '/icons/maskable-icon-512x512.png'
];

// CDN assets to cache
const CDN_ASSETS = [
  'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js',
  'https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.18.0/dist/tf.min.js',
  'https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js',
  'https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js',
  'https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js'
];

// Language models to cache (would be actual model files)
const LANGUAGE_MODELS = [
  '/models/swahili-sign/model.json',
  '/models/asl/model.json',
  '/models/bsl/model.json'
];

// Install event - cache static assets
self.addEventListener('install', (event) => {
  console.log('[Service Worker] Installing version 2.1.0');
  
  event.waitUntil(
    (async () => {
      const cache = await caches.open(CACHE_NAME);
      
      // Cache static assets
      await cache.addAll(STATIC_ASSETS);
      console.log('[Service Worker] Static assets cached');
      
      // Cache CDN assets in background
      event.waitUntil(
        (async () => {
          const cdnCache = await caches.open(MEDIA_CACHE_NAME);
          for (const url of CDN_ASSETS) {
            try {
              const response = await fetch(url, { mode: 'no-cors' });
              await cdnCache.put(url, response);
            } catch (error) {
              console.log(`[Service Worker] Failed to cache CDN asset: ${url}`);
            }
          }
        })()
      );
      
      // Force activation
      await self.skipWaiting();
    })()
  );
});

// Activate event - clean up old caches
self.addEventListener('activate', (event) => {
  console.log('[Service Worker] Activating');
  
  event.waitUntil(
    (async () => {
      // Clean old caches
      const cacheNames = await caches.keys();
      await Promise.all(
        cacheNames
          .filter(name => name.startsWith('signaid-') && name !== CACHE_NAME)
          .map(name => caches.delete(name))
      );
      
      // Take control of all clients
      await self.clients.claim();
      
      // Notify all clients
      const clients = await self.clients.matchAll();
      clients.forEach(client => {
        client.postMessage({
          type: 'SW_ACTIVATED',
          version: '2.1.0'
        });
      });
      
      console.log('[Service Worker] Ready');
    })()
  );
});

// Fetch event - advanced caching strategies
self.addEventListener('fetch', (event) => {
  const { request } = event;
  const url = new URL(request.url);

  // Skip cross-origin requests that aren't CDNs
  if (!url.origin.includes('localhost') && 
      !url.origin.includes('127.0.0.1') &&
      !CDN_ASSETS.some(cdn => url.href.includes(cdn))) {
    return;
  }

  // API requests - Network first, fallback to cache
  if (url.pathname.startsWith('/api/')) {
    event.respondWith(handleApiRequest(request));
    return;
  }

  // Media/CDN assets - Cache first, network fallback
  if (url.href.includes('cdn') || url.pathname.match(/\.(js|css|png|jpg|svg)$/)) {
    event.respondWith(handleMediaRequest(request));
    return;
  }

  // HTML navigation - Stale-while-revalidate
  if (request.mode === 'navigate') {
    event.respondWith(handleNavigationRequest(request));
    return;
  }

  // Default - Cache first, then network
  event.respondWith(handleDefaultRequest(request));
});

// Handle API requests
async function handleApiRequest(request) {
  try {
    // Try network first
    const networkResponse = await fetch(request);
    
    // Cache successful responses
    if (networkResponse.ok) {
      const cache = await caches.open(API_CACHE_NAME);
      cache.put(request, networkResponse.clone());
    }
    
    return networkResponse;
  } catch (error) {
    // Fallback to cache
    const cachedResponse = await caches.match(request);
    if (cachedResponse) {
      return cachedResponse;
    }
    
    // Return offline API response
    return new Response(
      JSON.stringify({ 
        error: 'offline', 
        message: 'You are offline. Using cached data.',
        timestamp: Date.now()
      }),
      {
        headers: { 'Content-Type': 'application/json' }
      }
    );
  }
}

// Handle media requests
async function handleMediaRequest(request) {
  const cachedResponse = await caches.match(request);
  if (cachedResponse) {
    // Return cached and update in background
    event.waitUntil(updateCache(request));
    return cachedResponse;
  }
  
  try {
    const networkResponse = await fetch(request);
    if (networkResponse.ok) {
      const cache = await caches.open(MEDIA_CACHE_NAME);
      cache.put(request, networkResponse.clone());
    }
    return networkResponse;
  } catch (error) {
    return new Response('Media unavailable offline', { status: 404 });
  }
}

// Handle navigation requests
async function handleNavigationRequest(request) {
  try {
    // Try network
    const networkResponse = await fetch(request);
    
    // Update cache
    const cache = await caches.open(CACHE_NAME);
    cache.put(request, networkResponse.clone());
    
    return networkResponse;
  } catch (error) {
    // Check cache
    const cachedResponse = await caches.match(request);
    if (cachedResponse) {
      return cachedResponse;
    }
    
    // Return offline page
    const offlineResponse = await caches.match(OFFLINE_URL);
    if (offlineResponse) {
      return offlineResponse;
    }
    
    // Last resort - generate offline page
    return new Response(
      '<html><body><h1>Offline</h1><p>Please check your connection</p></body></html>',
      {
        headers: { 'Content-Type': 'text/html' }
      }
    );
  }
}

// Handle default requests
async function handleDefaultRequest(request) {
  const cachedResponse = await caches.match(request);
  if (cachedResponse) {
    return cachedResponse;
  }
  
  try {
    const networkResponse = await fetch(request);
    if (networkResponse.ok && networkResponse.type === 'basic') {
      const cache = await caches.open(CACHE_NAME);
      cache.put(request, networkResponse.clone());
    }
    return networkResponse;
  } catch (error) {
    return new Response('Resource unavailable offline', { status: 404 });
  }
}

// Update cache in background
async function updateCache(request) {
  try {
    const networkResponse = await fetch(request);
    if (networkResponse.ok) {
      const cache = await caches.open(CACHE_NAME);
      cache.put(request, networkResponse);
    }
  } catch (error) {
    console.log('Background update failed:', error);
  }
}

// Background sync for offline translations
self.addEventListener('sync', (event) => {
  if (event.tag === 'sync-translations') {
    event.waitUntil(syncOfflineTranslations());
  }
  
  if (event.tag === 'sync-user-data') {
    event.waitUntil(syncUserData());
  }
});

async function syncOfflineTranslations() {
  try {
    const db = await openTranslationDB();
    const offlineTranslations = await db.getAll('pending');
    
    for (const translation of offlineTranslations) {
      try {
        const response = await fetch('/api/translate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(translation)
        });
        
        if (response.ok) {
          await db.delete('pending', translation.id);
        }
      } catch (error) {
        console.log('Sync failed for translation:', translation.id);
      }
    }
  } catch (error) {
    console.log('Sync error:', error);
  }
}

async function syncUserData() {
  // Sync user preferences, saved translations, etc.
  console.log('Syncing user data');
}

// IndexedDB for offline storage
function openTranslationDB() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('SIGNAIDOffline', 1);
    
    request.onupgradeneeded = (event) => {
      const db = event.target.result;
      if (!db.objectStoreNames.contains('pending')) {
        db.createObjectStore('pending', { keyPath: 'id', autoIncrement: true });
      }
      if (!db.objectStoreNames.contains('translations')) {
        db.createObjectStore('translations', { keyPath: 'id' });
      }
    };
    
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}

// Push notification handler
self.addEventListener('push', (event) => {
  const options = {
    body: event.data.text(),
    icon: '/icons/icon-192x192.png',
    badge: '/icons/icon-72x72.png',
    vibrate: [200, 100, 200],
    data: {
      dateOfArrival: Date.now(),
      primaryKey: 1,
      url: '/'
    },
    actions: [
      {
        action: 'open',
        title: 'Open SIGNAID'
      },
      {
        action: 'close',
        title: 'Dismiss'
      }
    ]
  };
  
  event.waitUntil(
    self.registration.showNotification('SIGNAID', options)
  );
});

// Notification click handler
self.addEventListener('notificationclick', (event) => {
  event.notification.close();
  
  if (event.action === 'open') {
    event.waitUntil(
      clients.openWindow(event.notification.data.url)
    );
  }
});

// Message handler
self.addEventListener('message', (event) => {
  if (event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
  
  if (event.data.type === 'CLEAR_CACHE') {
    event.waitUntil(clearOldCache());
  }
});

async function clearOldCache() {
  const cacheNames = await caches.keys();
  const oldCaches = cacheNames.filter(name => 
    name.startsWith('signaid-') && name !== CACHE_NAME
  );
  
  await Promise.all(oldCaches.map(name => caches.delete(name)));
  
  // Notify clients
  const clients = await self.clients.matchAll();
  clients.forEach(client => {
    client.postMessage({
      type: 'CACHE_CLEARED',
      caches: oldCaches
    });
  });
}

// Periodic sync (if supported)
self.addEventListener('periodicsync', (event) => {
  if (event.tag === 'update-models') {
    event.waitUntil(updateLanguageModels());
  }
});

async function updateLanguageModels() {
  console.log('Checking for model updates');
  // Implementation for model updates
}

console.log('[Service Worker] SIGNAID v2.1.0 loaded');
